---
layout: "../layouts/base.astro"
---

import Definition from "../components/Definition.astro";

### Cohesion

Just what is cohesion? In software terms it's routinely defined as "how well the elements of a module (think function, class or namespace for example) _go_ together". A quick look at a dictionary gives

<Definition
  word="cohesion"
  type="noun"
  definition="The action or fact of forming a united whole" />

Though I find _cohere_ to be a more helpful word. It's definition is

  <Definition
    word="cohere"
    type="verb"
    definition="(of an argument or theory) be logically consistent" />

Using the definition of cohere, the software-flavoured version of cohesion could be expressed as "the degree to which elements of a module are logically consistent". But why is this important?

#### Cognitive load
As far as I can tell it comes down to comprehension. A function who's elements and logic are soley oriented toward the functions spec will be easier to comprehend than a function whos elements and logic represent a multitude of concerns, because as well as trying to comprehend the spec for the flow through the function you're interested in you also have to identify and ignore any irrelevent elements which obviously requires more effort.

Another more subtle quality of cohesion refers to the level of detail for each element. While a function may be cohesive in that every element contributes to the stated spec, those elements might not all be represented at the same level of abstraction. For example

```js frame="terminal"
function processNewUserRegistration(userData) {
    // High-level abstraction: 'Valid' is a reasonable thing
    if (ensureValidUser(user) {
        throw new Error("Bad user registration data");
    }

    // Low-level abstraction: Directly interacting with database
    const config = {
        user: 'yourUsername',
        password: 'yourPassword',
        server: 'yourServer',
        database: 'yourDatabaseName'
    };

    // Open connection to the db
    await sql.connect(config);

    // Query to insert data
    const result = await sql.query`INSERT INTO Users (Name, Email) VALUES (${userData.name}, ${userData.email})`;

    sendWelcomeEmail(userData.email);

    // Low-level abstraction: Logging directly to console
    console.log(`User registered with ID: ${userId}`);

    // High-level abstraction: Returning a user object
    return {
        userId: userId,
        status: 'registered'
    };
}
```

Here we're validating user data, interacting with a database, logging to a console and sending a welcome email. All elements are necessary by reason of the function but clearly not all are at the same level of abstraction - inserting a value into a database does not require the same domain understanding, logic or reason required to evaluate what a "valid" user is. The up-and-down of detail in this example may be trivial to navigate but on a larger, more complex module it has a compounding effect. As an aside, what we've identified here is referred to as essential and incidental complexity; elements that pertain to the problem domain versus those that pertain to the solution domain.

As one improvement, the lower level incidental concerns of connecting to a database could expressed as a function call to persist the data, eliding the actual details of how thats done and better expressing the intent of our design that we want to persist the data; using a SQL database is just one way we could achieve that, we could also write it to a file, cache it in RAM or use a an external service via an HTTP API. The point being by expressing the all the elements at a level close to that of the function interface we make comprehension easier and less taxing.

In the end cohesion is about designing our modules such that we maximise the coherence of the elements within, both _what's_ in there and _how_ it's in there i.e. it's level of detail. In this way we make our system simpler and easier to reason about.
